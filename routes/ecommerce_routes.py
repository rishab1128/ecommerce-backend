from fastapi import APIRouter, HTTPException
from pymongo import ReturnDocument
from models.ecommerce_model import Product,Order
from config.db import connection
from schemas.ecommerce_schema import product_serializer, products_serializer, order_serializer, orders_serializer
from bson import ObjectId

route = APIRouter()
products_collection = connection.ecommerce.products
orders_collection = connection.ecommerce.orders
mp = {} #maps integer to actual object id's of the prodcuts generated by MongoDB
mp2 = {} #maps integer to actual object id's of the orders generated by MongoDB


@route.get("/")
def read_root():
    return {"Hello": "World"}


#PRODUCT ENDPOINTS

#1) List all avaiable products in the system
@route.get("/products")
async def list_products():
    products = products_collection.find({})
    productList = products_serializer(products)
    for i in range (0,len(productList)):
        mp[i+1]=str(productList[i]['id'])
    return {"status": "ok" , "productList": productList, "map": mp}


#2) Update a product (using product_id) when updating the available quantity for the product
@route.put("/products/{product_id}")
async def update_product(product_id: int, quantity: int):
    total_num_products = products_collection.count_documents({})
    if product_id not in mp or product_id < 1 or product_id > total_num_products:
        raise HTTPException(status_code=400, detail="Product ID should be between 1-{}".format(total_num_products))
    product_id = mp[product_id]
    products_collection.find_one_and_update({"_id": ObjectId(product_id)}, {"$set": {"Qty": quantity}})
    updated_product = products_serializer(products_collection.find({"_id":ObjectId(product_id)}))
    return {"status": "ok", "updated_product": updated_product}


#3) Create a new product
@route.post("/add_product")
async def add_product(product: Product):
    _id = products_collection.insert_one(dict(product))
    product = products_serializer(products_collection.find({"_id":_id.inserted_id}))
    return {"status":"ok", "product": product}


#################################################################################################################################################################################################


#ORDER ENDPOINTS

#4) Create a new order
@route.post("/create_order")
async def create_order(order: Order):
    for i in range(len(order.items)):
        order.items[i] = dict(order.items[i])
    order.user_address = dict(order.user_address)
    _id = orders_collection.insert_one(dict(order))
    order = orders_serializer(orders_collection.find({"_id":ObjectId(_id.inserted_id)}))
    return {"status":"ok", "order": order}


#5) Fetch all orders from the system (Also implement pagination using limit and offset)
@route.get("/orders")
async def list_orders(limit: int = 3, offset: int = 0):
    all_orders = orders_collection.find({})
    all_ordersList = orders_serializer(all_orders)
    total_num_orders = orders_collection.count_documents({})

    if limit+offset > total_num_orders:
        raise HTTPException(status_code=400, detail="Sum of Offset and Limit value exceeds the total number of orders ({} in this case)".format(total_num_orders))

    orders = orders_collection.find().skip(offset).limit(limit)
    orderList = orders_serializer(orders)

    for i in range (0,len(all_ordersList)):
        mp2[i+1]=str(all_ordersList[i]['id'])

    return {"status":"ok" , "orderList": orderList, "map": mp2}


#6) Get a specific order using order_id
@route.get("/orders/{order_id}")
async def get_specific_order(order_id:int):
    total_num_orders = orders_collection.count_documents({})
    if order_id not in mp2 or order_id < 1 or order_id > total_num_orders:
        raise HTTPException(status_code=400, detail="Order ID should be between 1-{}".format(total_num_orders))
    order_id = mp2[order_id]
    order = orders_serializer(orders_collection.find({"_id":ObjectId(order_id)}))
    return {"status":"ok" , "order": order}




